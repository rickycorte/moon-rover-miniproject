

# sets
#-------------------------------------------------
set Nodes;

# params
#-------------------------------------------------

param start symbolic in Nodes;


param value{Nodes};
# node positions in the space
param pos_x{Nodes};
param pos_y{Nodes};

param move_cost_km >=0;
param rot_cost_radiant >= 0;
param max_charge > 0;


# generated data
# do not assign this values, they are computed
#-------------------------------------------------

# this set is used to remove self arcs
# eg: 1 -> 1
set Arcs := setof{i in Nodes, j in Nodes: i <> j} (i,j);

# relative distance vectorc [j - i]
param x_diff{i in Nodes, j in Nodes} := (pos_x[j] - pos_x[i]);
param y_diff{i in Nodes, j in Nodes} := (pos_y[j] - pos_y[i]);

# eucliadian distance between two nodes
param dist{i in Nodes, j in Nodes} := sqrt(x_diff[i,j]^2 + y_diff[i,j]^2);


# vars
#-------------------------------------------------

var y{Nodes}, binary; 						# node selected
var x{Nodes, Nodes}, binary;    			# arc selected

var use_angle {Nodes, Nodes, Nodes} binary;	# support variable used to decide if we need to add the angle generated by i -> k -> j

# obj func
#-------------------------------------------------

maximize science_points:
	sum{k in Nodes} value[k] * y[k];


# constraints
#-------------------------------------------------

# start node constraints
subject to start_has_no_incoming_arcs:
	sum{(i,j) in Arcs: j = start} x[i, j] = 0;

subject to start_has_one_outgoing_arc:
	sum{(i,j) in Arcs: i = start} x[i,j] = 1;
	
subject to start_is_always_selected:
	y[start] = 1;

# constraints to arcs on nodes different from start
# this constraint also forces nodes that have one incoming arc to be selected by the solver
subject to max_one_incoming_arc{k in Nodes: k <> start}:
	sum{(i,j) in Arcs: j = k} x[i,j] = y[k];
	
# model that nodes must have at best one arc or none if final
subject to at_best_one_outgoing_arc{k in Nodes: k <> start}:
	sum{(i,j) in Arcs: i = k} x[i,j] <= y[k];

# force the solver to not geretare reflection arcs like and chose other nodes
# 1 -> 2
# 2 -> 1
subject to no_rifection{(i,j) in Arcs}:
	x[i,j] + x [j,i] <= 1;


# calculate used angles
# we must add this constraint to keep the problem linear and also to have a 0/1 variable
# that let the solver know if the angle between 2 arcs (3 nodes) should be used or not
subject to calc_use_angle{i in Nodes, k in Nodes, j in Nodes}:
	use_angle[i,k,j] >= x[i, k] + x[k, j] - 1;

# calculate the cost of a movent of selected arcs
subject to max_distance:
	sum{(i,j) in Arcs} dist[i, j] * x[i, j] * move_cost_km 
	+
	sum{i in Nodes, k in Nodes, j in Nodes: i <> j and i <> k and j <> k} 
		# rotation angle in rad (dot product between relative vectors from k node taken as center between) 
		# situation 
		# i -> k -> j
		(acos( 
				((x_diff[k,j] * x_diff[i,k]) + (y_diff[k,j] * y_diff[i,k]))
				/
				sqrt((x_diff[k,j]^2 + y_diff[k,j]^2) * (x_diff[i,k]^2 + y_diff[i,k]^2)
			 )
		) * use_angle[i,k,j] * rot_cost_radiant)
	<= max_charge;
	