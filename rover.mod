# Moon Rover Miniproject
# We modelled this problem as an fully connected graph were we enfoce the solver to avoid any kind of cicle.
# Why a graph?
# Because we can make any linear path from one node to another so connecting all nodes directly with linear paths
# generates a fully connected graph.
# On top of the graph we only need to ensure that the resulting path is acyclic (with transitive closure);
# that selected nodes have one incoming arc on one (or zero if final node) outgoing arcs and lastly that our total
# travel cost is under the maximum charge available.

# Node: 
# due to transtitive closure this code might require a bit of time to find a solution
# but the result is always correct and we do not incurr in possibile not connected cycles of arcs

# sets
#-------------------------------------------------
set Nodes;

# params
#-------------------------------------------------

param start symbolic in Nodes;

param value{Nodes};

# node positions in the space
param pos_x{Nodes};
param pos_y{Nodes};

param move_cost_km >=0;
param rot_cost_radiant >= 0;
param max_charge > 0;

# generated data
# computed with other parameters and set values
#-------------------------------------------------

# relative distance vector
# notation: x/y_diff[start, end]
param x_diff{i in Nodes, j in Nodes} := (pos_x[j] - pos_x[i]);
param y_diff{i in Nodes, j in Nodes} := (pos_y[j] - pos_y[i]);

# eucliadian distance
param dist{i in Nodes, j in Nodes} := sqrt(x_diff[i,j]^2 + y_diff[i,j]^2);


# vars
#-------------------------------------------------

# selected nodes
var y{Nodes}, binary; 

# arc selected
# notataion: x[start, end]
var x{Nodes, Nodes}, binary;  

# support variable used to compute transitive closure 
# that ensures that we have no cycles in our graph in any possibile situation
var acyc{Nodes, Nodes}, binary;	

# support variable used to decide if we need to add the angle generated by i -> k -> j
# notation: use_angle[start, angle center, end]
var use_angle {Nodes, Nodes, Nodes} binary;	

# obj func
#-------------------------------------------------

maximize science_points:
	sum{k in Nodes} value[k] * y[k];


# constraints
#-------------------------------------------------

# select the fist node
subject to start_node:
	y[start] = 1;

# transitive closure, ensure that we have proper connection between nodes
subject to first_transitve_closure{j in Nodes, i in Nodes}:
	x[i, j] <= acyc[i, j];

subject to transitive_closure{i in Nodes, j in Nodes, z in Nodes}:
	acyc[i, z] * acyc[z,j] <= acyc[i,j];

subject to acyclic_constraint{i in Nodes}:
	acyc[i, i] <=0;

subject to reachable_from_start{i in Nodes: i <> start}:
	y[i] = acyc[start,i];

# constraints to arcs on nodes different from start
# this constraint also forces nodes that have one incoming arc to be selected by the solver
subject to active_node_iif_incoming_arch {j in Nodes: j != start}:
	sum{i in Nodes} (x[i,j]) = y[j];

# model that nodes must have at best one arc or none if final
subject to max_one_outgoing{j in Nodes}:
	sum{i in Nodes} (x[j,i]) <= y[j];


# calculate used angles
# we must add this constraint to keep the problem linear and also to have a 0/1 variable
# that let the solver know if the angle between 2 arcs (3 nodes) should be used or not
subject to calc_use_angle{i in Nodes, k in Nodes, j in Nodes}:
	use_angle[i,k,j] >= x[i,k] + x[k,j] - 1;


# calculate the cost of a movent of selected arcs
subject to max_distance:
	# sum all active paths
	sum{i in Nodes, j in Nodes: i <> j} dist[i,j] * x[i,j] * move_cost_km
	+
	# sum all active rotations
	sum{i in Nodes, k in Nodes, j in Nodes: i <> j and i <> k and j <> k}
		# rotation angle in rad (dot product between relative vectors from k node taken as center between)
		# situation
		# i -> k -> j
		(acos(
				((x_diff[k,j] * x_diff[i,k]) + (y_diff[k,j] * y_diff[i,k]))
				/
				sqrt((x_diff[k,j]^2 + y_diff[k,j]^2) * (x_diff[i,k]^2 + y_diff[i,k]^2)
			 )
		) * use_angle[i,k,j] * rot_cost_radiant) <= max_charge;
